//main package has examples shown
// in Hands-On Data Structures and algorithms with Go book
/*package main
// importing bytes, crpto/sha256, encoding, fmt and log package
import (
 "bytes"
 "crypto/sha256"
 "encoding"
 "fmt"
 "log"
 "hash"
)

//main method
func main() {
	const (
	example1 = "this is a example "
	example2 = "second example"
	)
	var firstHash hash.Hash
	firstHash = sha256.New()
	firstHash.Write([]byte(example1))
	var marshaler encoding.BinaryMarshaler
	var ok bool
	marshaler, ok = firstHash.(encoding.BinaryMarshaler)
	if !ok {
	log.Fatal("first Hash is not generated by encoding.BinaryMarshaler")
	}
	var data []byte
	var err error
	data, err = marshaler.MarshalBinary()
	if err != nil {
	log.Fatal("failure to create first Hash:", err)
	}
	var secondHash hash.Hash
	secondHash = sha256.New()
   var unmarshaler encoding.BinaryUnmarshaler
	unmarshaler, ok = secondHash.(encoding.BinaryUnmarshaler)
	if !ok {
	log.Fatal("second Hash is not generated by encoding.BinaryUnmarshaler")
	}
	if err := unmarshaler.UnmarshalBinary(data); err != nil {
	log.Fatal("failure to create hash:", err)
	}
	firstHash.Write([]byte(example2))
	secondHash.Write([]byte(example2))
	fmt.Printf("%x\n", firstHash.Sum(nil))
	fmt.Println(bytes.Equal(firstHash.Sum(nil), secondHash.Sum(nil)))
   }*/

   //main package has examples shown
// in Go Data Structures and algorithms book
package main

// importing fmt package
import (
"fmt"
"crypto/sha256"
"hash"
//"encoding/base64"
//"math/rand"
"crypto/rand"
//"time"
//"strings"
)

//CreateHash method
func CreateHash(byteStr []byte) []byte {
var hashVal hash.Hash
hashVal = sha256.New()
hashVal.Write(byteStr)

var bytes []byte

bytes = hashVal.Sum(nil)
return bytes
}

// Create hash for Multiple Values method
func CreateHashMultiple(byteStr1 []byte, byteStr2 []byte) []byte {
	return xor(CreateHash(byteStr1), CreateHash(byteStr2))
  }

// XOR Method

func xor(byteStr1 []byte, byteStr2 []byte) []byte {
	var xorbytes []byte
	xorbytes = make([]byte, len(byteStr1))
	var i int
	for i = 0; i< len(byteStr1); i++ {
		xorbytes[i] = byteStr1[i] ^ byteStr2[i]
	}
	return xorbytes
}

// main method
func main() {

	
	/*var v []string
	//str  := []string{"check", "rijo"}
	//v := strings.Join(str, " ")

	bytes := CreateHashMultiple([]byte("PayerMSP"), []byte("Hash"))
	v = []string{base64.URLEncoding.EncodeToString(bytes)}
	
	fmt.Println(v)
	fmt.Printf("%x\n", base64.URLEncoding.EncodeToString(bytes))*/

	//s1 := rand.NewSource(time.Now().UnixNano())
	//r1 := rand.New(s1)
	r1, _ := rand.Prime(rand.Reader, 16)
	r2, _ := rand.Prime(rand.Reader, 16)
	fmt.Println(r1.String())
	fmt.Println(r1.String()+r2.String())
  }

  //main package has examples shown
// in Hands-On Data Structures and algorithms with Go book


/*package main

import (
	"crypto/sha256"
	"fmt"
	"encoding/base64"
)

func main() {
	sum := sha256.Sum256([]byte("hello world\n"))
	fmt.Printf("%x", sum)

	h := sha256.New()
	h.Write([]byte("hello world\n"))
	sha := base64.URLEncoding.EncodeToString(h.Sum(nil))
	fmt.Printf("%x", sha)


}*/